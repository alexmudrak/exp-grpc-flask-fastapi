Simple experiment with gRPC protocol on Flask and FastAPI

# gRPC
Идея протокола заключается в том, что клиентское приложение имеет возможность
вызывать методы на сервере таким образом, если бы приложение сервера размещалось
на локальной машине.

Другими словами, пространство имен серверного приложения становится доступным
для клиентского. Это должно значительно упростить работу коммуникации приложений
между собой.

`Protocol Buffers`- расширяемый механизм для сериализации структур данных.
Предоставляет формат сериалзации для типизированных пакетов структур данных
размером до нескольких мегабайт. Сообщения и службы описываются в файле `.proto`.

## Типы работы RPC
- Унарная операция, запрос клиента к сервера
- Сервер производит стриминг
- Клиент производит стриминг
- Двунаправленный стриминг клиента и сервера

`Deadline/Timeouts` - указывает на то, как долго клиенты могут ожидать ответа от
RPC перед тем как он будет закрыт с `DEADLINE_EXCEEDED`.

Так же клиент или сервер могут отменить RPC в любое время. __Изменения, которые
сделаны до отмены не возвращают свое состояние.__

## Metadata

Информация о конкретном вызове RPC, как вариант детали авторизации, в формате
ключ-значения (ASCII символами), ключи не должны начинаться с `grpc-`.
Ключи могут быть и бинарными данными, должны заканчиваться `-bin`.

# gRPC + Python
- Создать файл `.proto` с описанием сервиса, его методов и поддерживаемых
сообщений с их типами
- `pip install grpcio-tools` - генерация классов и методов для имплементации
сервера и клиента на основании описанного `.proto` файла.

# gRPC on Flask
# gRPC on FastAPI
# Как использовать
- `pipenv install` - установка необходимых пакетов
- `pipenv run gen_core` - Генерация сопуствующих классов для работы с описанными
методами и сообщениями в `./src/service.proto`
- `pipenv run start_server` - Запускает сервер gRPC на порту `50051`
- `pipenv run start_client` - Выводит 3 сообщения, 1 из которых информирует о
том, что объект не найден
